<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>使用Object 构造函数创建对象 | myblog</title>
    <meta name="generator" content="VuePress 1.5.4">
    
    <meta name="description" content="技术博客">
    <link rel="preload" href="/vuepressblog/assets/css/0.styles.e07c7e16.css" as="style"><link rel="preload" href="/vuepressblog/assets/js/app.021642e2.js" as="script"><link rel="preload" href="/vuepressblog/assets/js/2.98b326bc.js" as="script"><link rel="preload" href="/vuepressblog/assets/js/8.9282f287.js" as="script"><link rel="prefetch" href="/vuepressblog/assets/js/10.e800d49d.js"><link rel="prefetch" href="/vuepressblog/assets/js/11.69e8582a.js"><link rel="prefetch" href="/vuepressblog/assets/js/12.856711db.js"><link rel="prefetch" href="/vuepressblog/assets/js/13.e7cc01ac.js"><link rel="prefetch" href="/vuepressblog/assets/js/14.b2d45490.js"><link rel="prefetch" href="/vuepressblog/assets/js/15.f9c957ec.js"><link rel="prefetch" href="/vuepressblog/assets/js/16.f5d80386.js"><link rel="prefetch" href="/vuepressblog/assets/js/17.1c1e2527.js"><link rel="prefetch" href="/vuepressblog/assets/js/18.1cb2692d.js"><link rel="prefetch" href="/vuepressblog/assets/js/19.9243d857.js"><link rel="prefetch" href="/vuepressblog/assets/js/3.efe1fa85.js"><link rel="prefetch" href="/vuepressblog/assets/js/4.90e6410b.js"><link rel="prefetch" href="/vuepressblog/assets/js/5.a178c381.js"><link rel="prefetch" href="/vuepressblog/assets/js/6.262d752d.js"><link rel="prefetch" href="/vuepressblog/assets/js/7.4de95d1b.js"><link rel="prefetch" href="/vuepressblog/assets/js/9.8bdb9a19.js">
    <link rel="stylesheet" href="/vuepressblog/assets/css/0.styles.e07c7e16.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepressblog/" class="home-link router-link-active"><!----> <span class="site-name">myblog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepressblog/blog/.html#1" class="nav-link">
  待定
</a></div><div class="nav-item"><a href="/vuepressblog/blog/.html#2" class="nav-link">
  aboutme
</a></div><div class="nav-item"><a href="/vuepressblog/blog/.html#3" class="nav-link">
  github
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vuepressblog/blog/.html#1" class="nav-link">
  待定
</a></div><div class="nav-item"><a href="/vuepressblog/blog/.html#2" class="nav-link">
  aboutme
</a></div><div class="nav-item"><a href="/vuepressblog/blog/.html#3" class="nav-link">
  github
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/vuepressblog/blog/" aria-current="page" class="sidebar-link">home</a></li><li><a href="/vuepressblog/blog/elementui-Form.html" class="sidebar-link">elementui</a></li><li><a href="/vuepressblog/blog/elementui-loading.html" class="sidebar-link">解析elementui 中的v-loading指令</a></li><li><a href="/vuepressblog/blog/createObj.html" aria-current="page" class="active sidebar-link">使用Object 构造函数创建对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepressblog/blog/createObj.html#使用object-构造函数创建对象" class="sidebar-link">使用Object 构造函数创建对象</a></li><li class="sidebar-sub-header"><a href="/vuepressblog/blog/createObj.html#使用对象字面量创建对象" class="sidebar-link">使用对象字面量创建对象</a></li><li class="sidebar-sub-header"><a href="/vuepressblog/blog/createObj.html#构造函数模式" class="sidebar-link">构造函数模式</a></li><li class="sidebar-sub-header"><a href="/vuepressblog/blog/createObj.html#原型模式" class="sidebar-link">原型模式</a></li><li class="sidebar-sub-header"><a href="/vuepressblog/blog/createObj.html#isprototypeof" class="sidebar-link">isPrototypeOf()</a></li><li class="sidebar-sub-header"><a href="/vuepressblog/blog/createObj.html#ecmascript-5-增加了一个新方法-叫-object-getprototypeof" class="sidebar-link">ECMAScript 5 增加了一个新方法，叫 Object.getPrototypeOf()</a></li><li class="sidebar-sub-header"><a href="/vuepressblog/blog/createObj.html#原型对象的问题" class="sidebar-link">原型对象的问题</a></li><li class="sidebar-sub-header"><a href="/vuepressblog/blog/createObj.html#组合使用构造函数模式和原型模式" class="sidebar-link">组合使用构造函数模式和原型模式</a></li></ul></li><li><a href="/vuepressblog/blog/http常用状态码.html" class="sidebar-link">http常用状态码</a></li><li><a href="/vuepressblog/blog/js 防抖debounce与节流throttle.html" class="sidebar-link">js 防抖debounce与节流throttle</a></li><li><a href="/vuepressblog/blog/LinuxData.html" class="sidebar-link">linux</a></li><li><a href="/vuepressblog/blog/promise.html" class="sidebar-link">promise</a></li><li><a href="/vuepressblog/blog/reduce.html" class="sidebar-link">reduce</a></li><li><a href="/vuepressblog/blog/linuxNginx自启动.html" class="sidebar-link">linuxNginx自启动</a></li><li><a href="/vuepressblog/blog/reflow&amp;repaint.html" class="sidebar-link">回流与重绘</a></li><li><a href="/vuepressblog/blog/固定表头和列的表格.html" class="sidebar-link">表格固定表头和列</a></li><li><a href="/vuepressblog/blog/vue-virtual-scroll-list.html" class="sidebar-link">vue虚拟滚动（vue-virtual-scroll-list）</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="使用object-构造函数创建对象"><a href="#使用object-构造函数创建对象" class="header-anchor">#</a> 使用Object 构造函数创建对象</h2> <div class="language- extra-class"><pre><code>var person = new Object();
person.name = 'zs';
person.age = 19;
person.sayName = function(){
    console.log(this.name);
}
</code></pre></div><h2 id="使用对象字面量创建对象"><a href="#使用对象字面量创建对象" class="header-anchor">#</a> 使用对象字面量创建对象</h2> <div class="language- extra-class"><pre><code>var person = {
    name:'zs',
    age:19,
    sayName:function(){
        console.log(this.name);
    }
}
</code></pre></div><p>虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。所以工厂模式应用而生。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span>age</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    o<span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    o<span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    o<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> o<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">'zs'</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token function">createPerson</span><span class="token punctuation">(</span><span class="token string">'li'</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>​</p> <h2 id="构造函数模式"><a href="#构造函数模式" class="header-anchor">#</a> 构造函数模式</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>   function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function(){
    alert(this.name);
    };
   }
   var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
   var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><blockquote><p>要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4个步骤：
(1) 创建一个新对象；
(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；
(3) 执行构造函数中的代码（为这个新对象添加属性）；
(4) 返回新对象。</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>alert(person1.constructor == Person); //true
alert(person2.constructor == Person); //true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>提到检测对象类型，还是 instanceof 操作符要更可靠一些。</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>alert(person1 instanceof Object); //true
alert(person1 instanceof Person); //true
alert(person2 instanceof Object); //true
alert(person2 instanceof Person); //true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>    // 当作构造函数使用
    var person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
    person.sayName(); //&quot;Nicholas&quot;
    // 作为普通函数调用
    Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;); // 添加到 window
    window.sayName(); //&quot;Greg&quot;
    // 在另一个对象的作用域中调用
    var o = new Object();
    Person.call(o, &quot;Kristen&quot;, 25, &quot;Nurse&quot;);
    o.sayName(); //&quot;Kristen&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><blockquote><p>构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。因此，大可像下面这样，通过把函数定义转移到构造函数外部来解决这个问题。</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>function Person(name, age, job){
this.name = name;
this.age = age;
this.job = job;
this.sayName = sayName;
}
function sayName(){
alert(this.name);
}
var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);
var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。</p> <h2 id="原型模式"><a href="#原型模式" class="header-anchor">#</a> 原型模式</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>function Person(){
}
Person.prototype.name = &quot;Nicholas&quot;;
Person.prototype.age = 29;
Person.prototype.job = &quot;Software Engineer&quot;;
Person.prototype.sayName = function(){
alert(this.name);
};
var person1 = new Person();
person1.sayName(); //&quot;Nicholas&quot;
var person2 = new Person();
person2.sayName(); //&quot;Nicholas&quot;
alert(person1.sayName == person2.sayName); //true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="isprototypeof"><a href="#isprototypeof" class="header-anchor">#</a> isPrototypeOf()</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>alert(Person.prototype.isPrototypeOf(person1)); //true
alert(Person.prototype.isPrototypeOf(person2)); //true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="ecmascript-5-增加了一个新方法-叫-object-getprototypeof"><a href="#ecmascript-5-增加了一个新方法-叫-object-getprototypeof" class="header-anchor">#</a> ECMAScript 5 增加了一个新方法，叫 Object.getPrototypeOf()</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>alert(Object.getPrototypeOf(person1) == Person.prototype); //true
alert(Object.getPrototypeOf(person1).name); //&quot;Nicholas&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>使用 hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。只在给定属性存在于对象实例中时，才会返回 true。
有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时，in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>alert(person1.hasOwnProperty(&quot;name&quot;)); //false
alert(&quot;name&quot; in person1); //true
//该方法可以确定该属性到底是存在于对象中，还是存在于原型中
function hasPrototypeProperty(object, name){
return !object.hasOwnProperty(name) &amp;&amp; (name in object);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="原型对象的问题"><a href="#原型对象的问题" class="header-anchor">#</a> 原型对象的问题</h2> <p>// 对于包含引用类型值的属性来说，一个对象改变了friends另一个对象会跟着改变</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function Person(){
}
Person.prototype = {
  constructor: Person,
  name : &quot;Nicholas&quot;,
  age : 29,
  job : &quot;Software Engineer&quot;,
  friends : [&quot;Shelby&quot;, &quot;Court&quot;],
  sayName : function () {
  alert(this.name);
  }
};
var person1 = new Person();
var person2 = new Person();
person1.friends.push(&quot;Van&quot;);
alert(person1.friends); //&quot;Shelby,Court,Van&quot;
alert(person2.friends); //&quot;Shelby,Court,Van&quot;
alert(person1.friends === person2.friends); //true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="header-anchor">#</a> 组合使用构造函数模式和原型模式</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vuepressblog/blog/elementui-loading.html" class="prev">
        解析elementui 中的v-loading指令
      </a></span> <span class="next"><a href="/vuepressblog/blog/http常用状态码.html">
        http常用状态码
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/vuepressblog/assets/js/app.021642e2.js" defer></script><script src="/vuepressblog/assets/js/2.98b326bc.js" defer></script><script src="/vuepressblog/assets/js/8.9282f287.js" defer></script>
  </body>
</html>
